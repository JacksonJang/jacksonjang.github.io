

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>/</id>
  <title>Jacksonjang Blog</title>
  <subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle>
  <updated>2026-02-02T20:10:47+09:00</updated>
  <author>
    <name>Jacksonjang</name>
    <uri>/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="/"/>
  <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator>
  <rights> © 2026 Jacksonjang </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Spring Data JPA - OSIV(Open Session In View) 정리(+논란 포함)</title>
    <link href="/posts/spring-data-jpa-osiv-mode/" rel="alternate" type="text/html" title="Spring Data JPA - OSIV(Open Session In View) 정리(+논란 포함)" />
    <published>2026-02-03T04:00:00+09:00</published>
  
    <updated>2026-02-03T04:00:00+09:00</updated>
  
    <id>/posts/spring-data-jpa-osiv-mode/</id>
    <content type="text/html" src="/posts/spring-data-jpa-osiv-mode/" />
    <author>
      <name>JacksonJang</name>
    </author>

  
    
    <category term="Spring Boot" />
    
  

  <summary>OSIV 활성화 시 나타나는 메시지 spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning  로그에 보이는 메시지는 Spring Boot의 OSIV(Open Session In View) 설정이 기본적으로 활성화되어 있음을 알려줍니다. 이 설정 값이 왜 중요하고, 개발자들 사이에서 논란이 있었는지 자세히 알아보겠습니다.  OSIV 모드란? OSIV는 영속성 컨텍스트를 HTTP 응답이 완전히 전송될 때까지 유지하는 기능입니다.     ...</summary>

  </entry>

  
  <entry>
    <title>JPA N+1 문제 해결하기</title>
    <link href="/posts/spring-jpa-n+1/" rel="alternate" type="text/html" title="JPA N+1 문제 해결하기" />
    <published>2026-01-26T05:00:00+09:00</published>
  
    <updated>2026-01-26T05:00:00+09:00</updated>
  
    <id>/posts/spring-jpa-n+1/</id>
    <content type="text/html" src="/posts/spring-jpa-n+1/" />
    <author>
      <name>JacksonJang</name>
    </author>

  
    
    <category term="Spring Boot" />
    
  

  <summary>N+1 문제란? N+1 문제는 데이터를 1건 조회했을 때, 연관된 데이터를 가져오기 위해 N번의 쿼리가 추가로 실행되는 현상입니다.  N+1 문제 발생 예시 팀(Team)이 10개 있다고 가정하고 팀(Team) 목록을 조회한 뒤, 각 팀의 멤버(Member)를 조회하면 총 11번(1+10(N))의 쿼리가 발생합니다.  왜 11번의 쿼리가 발생하게 되는가? @Entity public class Team {     @Id     @GeneratedValue(strategy = GenerationType.IDENTITY)     private Long id;      private String name;      @OneToMany(mappedBy = &amp;quot;team&amp;quot;, fetch = FetchType.LAZY)...</summary>

  </entry>

  
  <entry>
    <title>Spring Boot와 함께 Database Replication 사용하기</title>
    <link href="/posts/database-replication-with-spring-boot/" rel="alternate" type="text/html" title="Spring Boot와 함께 Database Replication 사용하기" />
    <published>2025-08-17T22:00:00+09:00</published>
  
    <updated>2025-08-17T22:00:00+09:00</updated>
  
    <id>/posts/database-replication-with-spring-boot/</id>
    <content type="text/html" src="/posts/database-replication-with-spring-boot/" />
    <author>
      <name>JacksonJang</name>
    </author>

  
    
    <category term="Spring Boot" />
    
  

  <summary>앞서 정리한 Database Replication 사용하기(with MySQL) 글에서 살펴본 것처럼, Spring Boot 환경에서도 동일하게 적용할 수 있습니다.  Master/Source와 Slave/Replica의 명칭 관련해서는 설명의 편의를 위해 Master와 Replica를 사용하겠습니다. (MySQL 8.0 이후로 Master/Slave -&amp;amp;gt; Source/Replica 로 변경되었습니다.)  @Transactional을 이용해서 사용하기 Spring Boot에서는 @Transactional 을 통해 Master로 보낼지, Replica로 보낼지 정할 수 있습니다.  Spring Boot에서는 기본적으로 DB(DataSource)에 연결할지 결정하는 기능은 내장되어 있지 않기 때문에 ...</summary>

  </entry>

  
  <entry>
    <title>Database Replication 사용하기(with MySQL)</title>
    <link href="/posts/database-replication/" rel="alternate" type="text/html" title="Database Replication 사용하기(with MySQL)" />
    <published>2025-08-09T22:00:00+09:00</published>
  
    <updated>2025-08-09T22:00:00+09:00</updated>
  
    <id>/posts/database-replication/</id>
    <content type="text/html" src="/posts/database-replication/" />
    <author>
      <name>JacksonJang</name>
    </author>

  
    
    <category term="DevOps" />
    
  

  <summary>고객사의 대규모 서비스를 도입하게 되어, 관련 내용을 정리하게 되었습니다.  Database Replication 이란? 사용자가 많은 서비스에서는 하나의 DB로 모든 요청을 처리하기 어려울 수 있습니다. 그래서 이를 해결하기 위해 고안된 기술이 Database Replication입니다.  Database를 Replication(복제)해서 DB Read/Write 역할을 나눠서 성능과 안정성을 증가시키고, 일반적으로 Source/Replica 구조를 사용하며 다음과 같은 역할을 수행합니다.     Source(혹은 Master) : Write(INSERT, UPDATE, DELETE)   Replica(혹은 Slave) : Read(SELECT)   *참고 : MySQL 8.0 이후로 Master/S...</summary>

  </entry>

  
  <entry>
    <title>[Spring Boot] 에러를 효과적으로 처리하는 2가지 방법(@ExceptionHandler, @ControllerAdvice 사용)</title>
    <link href="/posts/spring-boot-error-handler/" rel="alternate" type="text/html" title="[Spring Boot] 에러를 효과적으로 처리하는 2가지 방법(@ExceptionHandler, @ControllerAdvice 사용)" />
    <published>2025-08-03T23:00:00+09:00</published>
  
    <updated>2025-08-03T23:00:00+09:00</updated>
  
    <id>/posts/spring-boot-error-handler/</id>
    <content type="text/html" src="/posts/spring-boot-error-handler/" />
    <author>
      <name>JacksonJang</name>
    </author>

  
    
    <category term="Spring Boot" />
    
  

  <summary>왜 필요해요? 프로젝트를 진행하다 보면 에러 응답 포맷을 변경해야 하는 상황이 생길 수 있습니다. 예를 들어, 고객 요구사항 변경, 공통 응답 규격 개편, 코드 리팩터링 등..  이때 모든 컨트롤러에 동일한 보일러플레이트 코드가 존재해서 수정할 때 유지보수 비용이 커집니다.  try-catch 문 @RestController public class TryCatchController {    @GetMapping(&amp;quot;/tryCatch&amp;quot;)   public String tryCatch() {     try {       throw new IllegalArgumentException(&amp;quot;IllegalArgument 에러&amp;quot;);     } catch (Exception e) {       return &amp;quot;에러가 발생했...</summary>

  </entry>

</feed>


