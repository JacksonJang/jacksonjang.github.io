

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>/</id>
  <title>Jacksonjang Blog</title>
  <subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle>
  <updated>2026-02-02T20:10:06+09:00</updated>
  <author>
    <name>Jacksonjang</name>
    <uri>/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="/"/>
  <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator>
  <rights> © 2026 Jacksonjang </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>JPA N+1 문제 해결하기</title>
    <link href="/posts/spring-jpa-n+1/" rel="alternate" type="text/html" title="JPA N+1 문제 해결하기" />
    <published>2026-01-26T05:00:00+09:00</published>
  
    <updated>2026-01-26T05:00:00+09:00</updated>
  
    <id>/posts/spring-jpa-n+1/</id>
    <content type="text/html" src="/posts/spring-jpa-n+1/" />
    <author>
      <name>JacksonJang</name>
    </author>

  
    
    <category term="Spring Boot" />
    
  

  <summary>N+1 문제란? N+1 문제는 데이터를 1건 조회했을 때, 연관된 데이터를 가져오기 위해 N번의 쿼리가 추가로 실행되는 현상입니다.  N+1 문제 발생 예시 팀(Team)이 10개 있다고 가정하고 팀(Team) 목록을 조회한 뒤, 각 팀의 멤버(Member)를 조회하면 총 11번(1+10(N))의 쿼리가 발생합니다.  왜 11번의 쿼리가 발생하게 되는가? @Entity public class Team {     @Id     @GeneratedValue(strategy = GenerationType.IDENTITY)     private Long id;      private String name;      @OneToMany(mappedBy = &amp;quot;team&amp;quot;, fetch = FetchType.LAZY)...</summary>

  </entry>

  
  <entry>
    <title>Spring Boot와 함께 Database Replication 사용하기</title>
    <link href="/posts/database-replication-with-spring-boot/" rel="alternate" type="text/html" title="Spring Boot와 함께 Database Replication 사용하기" />
    <published>2025-08-17T22:00:00+09:00</published>
  
    <updated>2025-08-17T22:00:00+09:00</updated>
  
    <id>/posts/database-replication-with-spring-boot/</id>
    <content type="text/html" src="/posts/database-replication-with-spring-boot/" />
    <author>
      <name>JacksonJang</name>
    </author>

  
    
    <category term="Spring Boot" />
    
  

  <summary>앞서 정리한 Database Replication 사용하기(with MySQL) 글에서 살펴본 것처럼, Spring Boot 환경에서도 동일하게 적용할 수 있습니다.  Master/Source와 Slave/Replica의 명칭 관련해서는 설명의 편의를 위해 Master와 Replica를 사용하겠습니다. (MySQL 8.0 이후로 Master/Slave -&amp;amp;gt; Source/Replica 로 변경되었습니다.)  @Transactional을 이용해서 사용하기 Spring Boot에서는 @Transactional 을 통해 Master로 보낼지, Replica로 보낼지 정할 수 있습니다.  Spring Boot에서는 기본적으로 DB(DataSource)에 연결할지 결정하는 기능은 내장되어 있지 않기 때문에 ...</summary>

  </entry>

  
  <entry>
    <title>Database Replication 사용하기(with MySQL)</title>
    <link href="/posts/database-replication/" rel="alternate" type="text/html" title="Database Replication 사용하기(with MySQL)" />
    <published>2025-08-09T22:00:00+09:00</published>
  
    <updated>2025-08-09T22:00:00+09:00</updated>
  
    <id>/posts/database-replication/</id>
    <content type="text/html" src="/posts/database-replication/" />
    <author>
      <name>JacksonJang</name>
    </author>

  
    
    <category term="DevOps" />
    
  

  <summary>고객사의 대규모 서비스를 도입하게 되어, 관련 내용을 정리하게 되었습니다.  Database Replication 이란? 사용자가 많은 서비스에서는 하나의 DB로 모든 요청을 처리하기 어려울 수 있습니다. 그래서 이를 해결하기 위해 고안된 기술이 Database Replication입니다.  Database를 Replication(복제)해서 DB Read/Write 역할을 나눠서 성능과 안정성을 증가시키고, 일반적으로 Source/Replica 구조를 사용하며 다음과 같은 역할을 수행합니다.     Source(혹은 Master) : Write(INSERT, UPDATE, DELETE)   Replica(혹은 Slave) : Read(SELECT)   *참고 : MySQL 8.0 이후로 Master/S...</summary>

  </entry>

  
  <entry>
    <title>[Spring Boot] 에러를 효과적으로 처리하는 2가지 방법(@ExceptionHandler, @ControllerAdvice 사용)</title>
    <link href="/posts/spring-boot-error-handler/" rel="alternate" type="text/html" title="[Spring Boot] 에러를 효과적으로 처리하는 2가지 방법(@ExceptionHandler, @ControllerAdvice 사용)" />
    <published>2025-08-03T23:00:00+09:00</published>
  
    <updated>2025-08-03T23:00:00+09:00</updated>
  
    <id>/posts/spring-boot-error-handler/</id>
    <content type="text/html" src="/posts/spring-boot-error-handler/" />
    <author>
      <name>JacksonJang</name>
    </author>

  
    
    <category term="Spring Boot" />
    
  

  <summary>왜 필요해요? 프로젝트를 진행하다 보면 에러 응답 포맷을 변경해야 하는 상황이 생길 수 있습니다. 예를 들어, 고객 요구사항 변경, 공통 응답 규격 개편, 코드 리팩터링 등..  이때 모든 컨트롤러에 동일한 보일러플레이트 코드가 존재해서 수정할 때 유지보수 비용이 커집니다.  try-catch 문 @RestController public class TryCatchController {    @GetMapping(&amp;quot;/tryCatch&amp;quot;)   public String tryCatch() {     try {       throw new IllegalArgumentException(&amp;quot;IllegalArgument 에러&amp;quot;);     } catch (Exception e) {       return &amp;quot;에러가 발생했...</summary>

  </entry>

  
  <entry>
    <title>[JavaScript] null vs undefined 차이 제대로 알기</title>
    <link href="/posts/js-null-undefined/" rel="alternate" type="text/html" title="[JavaScript] null vs undefined 차이 제대로 알기" />
    <published>2025-07-28T03:00:00+09:00</published>
  
    <updated>2025-07-28T03:00:00+09:00</updated>
  
    <id>/posts/js-null-undefined/</id>
    <content type="text/html" src="/posts/js-null-undefined/" />
    <author>
      <name>JacksonJang</name>
    </author>

  
    
    <category term="JavaScript" />
    
  

  <summary>JavaScript 의 null, undefined 알아보기 undefined 의미 JavaScript에서 undefined는 변수를 선언하고 값을 할당하지 않은 상태를 의미합니다. let x;   null 의미 null은 변수를 선언하고 빈 값을 할당한 상태입니다. let x = null;   위 차이에 대해 구분하는 테스트하기(typeof 사용) JavaScript에서는 typeof 라는 연산자가 있습니다. 이 연산자를 이용해서 타입들에 대해 볼 수 있는데 아래와 같이 Console 창에서 바로 확인 가능합니다.   typeof null         // &amp;#39;object&amp;#39; typeof undefined    // &amp;#39;undefined&amp;#39; typeof 1            // &amp;#39;number&amp;#39; type...</summary>

  </entry>

</feed>


