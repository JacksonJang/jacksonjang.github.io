

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>/</id>
  <title>Jacksonjang Blog</title>
  <subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle>
  <updated>2025-10-28T20:50:39+09:00</updated>
  <author>
    <name>Jacksonjang</name>
    <uri>/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="/"/>
  <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator>
  <rights> © 2025 Jacksonjang </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Spring Boot와 함께 Database Replication 사용하기</title>
    <link href="/posts/database-replication-with-spring-boot/" rel="alternate" type="text/html" title="Spring Boot와 함께 Database Replication 사용하기" />
    <published>2025-08-17T22:00:00+09:00</published>
  
    <updated>2025-08-17T22:00:00+09:00</updated>
  
    <id>/posts/database-replication-with-spring-boot/</id>
    <content type="text/html" src="/posts/database-replication-with-spring-boot/" />
    <author>
      <name>JacksonJang</name>
    </author>

  
    
    <category term="Spring Boot" />
    
  

  <summary>앞서 정리한 Database Replication 사용하기(with MySQL) 글에서 살펴본 것처럼,  Spring Boot 환경에서도 동일하게 적용할 수 있습니다.  Master/Source와 Slave/Replica의 명칭 관련해서는 설명의 편의를 위해 Master와 Replica를 사용하겠습니다. (MySQL 8.0 이후로 Master/Slave -&amp;amp;gt; Source/Replica 로 변경되었습니다.)  @Transactional을 이용해서 사용하기 Spring Boot에서는 @Transactional 을 통해 Master로 보낼지, Replica로 보낼지 정할 수 있습니다.  Spring Boot에서는 기본적으로 DB(DataSource)에 연결할지 결정하는 기능은 내장되어 있지 않기 때문에...</summary>

  </entry>

  
  <entry>
    <title>Database Replication 사용하기(with MySQL)</title>
    <link href="/posts/database-replication/" rel="alternate" type="text/html" title="Database Replication 사용하기(with MySQL)" />
    <published>2025-08-09T22:00:00+09:00</published>
  
    <updated>2025-08-09T22:00:00+09:00</updated>
  
    <id>/posts/database-replication/</id>
    <content type="text/html" src="/posts/database-replication/" />
    <author>
      <name>JacksonJang</name>
    </author>

  
    
    <category term="DevOps" />
    
  

  <summary>고객사의 대규모 서비스를 도입하게 되어, 관련 내용을 정리하게 되었습니다.  Database Replication 이란? 사용자가 많은 서비스에서는 하나의 DB로 모든 요청을 처리하기 어려울 수 있습니다. 그래서 이를 해결하기 위해 고안된 기술이 Database Replication입니다.   Database를 Replication(복제)해서 DB Read/Write 역할을 나눠서 성능과 안정성을 증가시키고, 일반적으로 Source/Replica 구조를 사용하며 다음과 같은 역할을 수행합니다.     Source(혹은 Master) : Write(INSERT, UPDATE, DELETE)   Replica(혹은 Slave) : Read(SELECT)    *참고 : MySQL 8.0 이후로 Master...</summary>

  </entry>

  
  <entry>
    <title>[Spring Boot] 에러를 효과적으로 처리하는 2가지 방법(@ExceptionHandler, @ControllerAdvice 사용)</title>
    <link href="/posts/spring-boot-error-handler/" rel="alternate" type="text/html" title="[Spring Boot] 에러를 효과적으로 처리하는 2가지 방법(@ExceptionHandler, @ControllerAdvice 사용)" />
    <published>2025-08-03T23:00:00+09:00</published>
  
    <updated>2025-08-03T23:00:00+09:00</updated>
  
    <id>/posts/spring-boot-error-handler/</id>
    <content type="text/html" src="/posts/spring-boot-error-handler/" />
    <author>
      <name>JacksonJang</name>
    </author>

  
    
    <category term="Spring Boot" />
    
  

  <summary>왜 필요해요? 프로젝트를 진행하다 보면 에러 응답 포맷을 변경해야 하는 상황이 생길 수 있습니다. 예를 들어, 고객 요구사항 변경, 공통 응답 규격 개편, 코드 리팩터링 등..  이때 모든 컨트롤러에 동일한 보일러플레이트 코드가 존재해서 수정할 때 유지보수 비용이 커집니다.    try-catch 문 @RestController public class TryCatchController {    @GetMapping(&amp;quot;/tryCatch&amp;quot;)   public String tryCatch() {     try {       throw new IllegalArgumentException(&amp;quot;IllegalArgument 에러&amp;quot;);     } catch (Exception e) {       return &amp;quot;에러가 발...</summary>

  </entry>

  
  <entry>
    <title>[JavaScript] null vs undefined 차이 제대로 알기</title>
    <link href="/posts/js-null-undefined/" rel="alternate" type="text/html" title="[JavaScript] null vs undefined 차이 제대로 알기" />
    <published>2025-07-28T03:00:00+09:00</published>
  
    <updated>2025-07-28T03:00:00+09:00</updated>
  
    <id>/posts/js-null-undefined/</id>
    <content type="text/html" src="/posts/js-null-undefined/" />
    <author>
      <name>JacksonJang</name>
    </author>

  
    
    <category term="JavaScript" />
    
  

  <summary>JavaScript 의 null, undefined 알아보기 undefined 의미 JavaScript에서 undefined는 변수를 선언하고 값을 할당하지 않은 상태를 의미합니다. let x;    null 의미 null은 변수를 선언하고 빈 값을 할당한 상태입니다. let x = null;    위 차이에 대해 구분하는 테스트하기(typeof 사용) JavaScript에서는 typeof 라는 연산자가 있습니다.  이 연산자를 이용해서 타입들에 대해 볼 수 있는데 아래와 같이 Console 창에서 바로 확인 가능합니다.    typeof null         // &amp;#39;object&amp;#39; typeof undefined    // &amp;#39;undefined&amp;#39; typeof 1            // &amp;#39;number&amp;#39; ...</summary>

  </entry>

  
  <entry>
    <title>[SwiftUI] @ObservedObject vs @StateObject</title>
    <link href="/posts/ObservedObject-vs-StateObject/" rel="alternate" type="text/html" title="[SwiftUI] @ObservedObject vs @StateObject" />
    <published>2024-08-06T04:00:00+09:00</published>
  
    <updated>2024-08-06T04:00:00+09:00</updated>
  
    <id>/posts/ObservedObject-vs-StateObject/</id>
    <content type="text/html" src="/posts/ObservedObject-vs-StateObject/" />
    <author>
      <name>JacksonJang</name>
    </author>

  
    
    <category term="iOS" />
    
  

  <summary>핵심 정리    공통점 : 객체의 상태 변화를 감지하고 뷰를 업데이트하는 데 사용되는 속성 래퍼입니다.   @StateObject는 부모 뷰가 직접 객체를 소유하고 관리합니다.   @ObservedObject는 부모 뷰에서 객체를 관찰하고 업데이트를 반영합니다.   ObservableObject 란? @StateObject 와 @ObservedObject에 대해 알기 전에 우선적으로 ObservableObject 라는 프로토콜에 대해 이해할 필요가 있습니다.  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *) public protocol ObservableObject : AnyObject {      /// The type of publishe...</summary>

  </entry>

</feed>


